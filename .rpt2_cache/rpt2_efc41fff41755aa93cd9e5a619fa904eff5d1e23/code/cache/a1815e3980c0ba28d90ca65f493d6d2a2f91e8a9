{"code":"import { RadToDeg } from '../util/radDeg';\r\nexport default class Vector {\r\n    constructor({ x, y } = { x: 0, y: 0 }) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    clone() {\r\n        return new Vector({ x: this.x, y: this.y });\r\n    }\r\n    magnitude() {\r\n        const x = this.x * this.x;\r\n        const y = this.y * this.y;\r\n        const magnitude = Math.sqrt(x + y);\r\n        return magnitude;\r\n    }\r\n    dotProduct({ x, y }) {\r\n        return this.x * x + this.y * y;\r\n    }\r\n    add(vector) {\r\n        const x = this.x + vector.x;\r\n        const y = this.y + vector.y;\r\n        return new Vector({ x, y });\r\n    }\r\n    sub(vector) {\r\n        const x = this.x + -vector.x;\r\n        const y = this.y + -vector.y;\r\n        return new Vector({ x, y });\r\n    }\r\n    multiplyScalar(scalar) {\r\n        const x = this.x * scalar;\r\n        const y = this.y * scalar;\r\n        return new Vector({ x, y });\r\n    }\r\n    normalize() {\r\n        const magnitude = this.magnitude();\r\n        const x = this.x / magnitude;\r\n        const y = this.y / magnitude;\r\n        return new Vector({ x, y });\r\n    }\r\n    lerp(vector, alpha) {\r\n        const x = this.x + (vector.x - this.x) * alpha;\r\n        const y = this.y + (vector.y - this.y) * alpha;\r\n        return new Vector({ x, y });\r\n    }\r\n    negative() {\r\n        const x = -this.x;\r\n        const y = -this.y;\r\n        return new Vector({ x, y });\r\n    }\r\n    perpendicular() {\r\n        const right = new Vector({ x: -this.y, y: this.x });\r\n        const left = new Vector({ x: this.y, y: -this.x });\r\n        return { left, right };\r\n    }\r\n    scale(length) {\r\n        const normalized = this.normalize();\r\n        const x = normalized.x * length;\r\n        const y = normalized.y * length;\r\n        return new Vector({ x, y });\r\n    }\r\n    angleDeg(vector) {\r\n        const angle = this.angle(vector);\r\n        return RadToDeg(angle);\r\n    }\r\n    angleRad(vector) {\r\n        return this.angle(vector);\r\n    }\r\n    bisector(vector) {\r\n        const normalized = this.normalize();\r\n        const normalizedVector = vector.normalize();\r\n        const sum = normalized.add(normalizedVector);\r\n        const magnitude = (this.magnitude() + vector.magnitude()) / 2;\r\n        return sum.scale(magnitude);\r\n    }\r\n    equals(vector) {\r\n        return this.x === vector.x && this.y === vector.y;\r\n    }\r\n    distanceTo(vector) {\r\n        return this.sub(vector).magnitude();\r\n    }\r\n    midpoint(vector) {\r\n        const x = (this.x + vector.x) / 2;\r\n        const y = (this.y + vector.y) / 2;\r\n        return new Vector({ x, y });\r\n    }\r\n    static FindPolyCentroid(points) {\r\n        let x = 0;\r\n        let y = 0;\r\n        points.forEach((point) => {\r\n            x += point.x;\r\n            y += point.y;\r\n        });\r\n        x /= points.length;\r\n        y /= points.length;\r\n        return new Vector({ x, y });\r\n    }\r\n    static ArrangePointsCCW(points) {\r\n        const centroid = Vector.FindPolyCentroid(points);\r\n        let clone = [...points];\r\n        clone.sort((a, b) => {\r\n            const angleA = Math.atan2(a.y - centroid.y, a.x - centroid.x);\r\n            const angleB = Math.atan2(b.y - centroid.y, b.x - centroid.x);\r\n            return angleA - angleB;\r\n        });\r\n        return clone;\r\n    }\r\n    static UniqueFromArray(points) {\r\n        const isUnique = (vector, index, array) => {\r\n            return (array.findIndex((vectorIndex) => {\r\n                return vector.equals(vectorIndex);\r\n            }) === index);\r\n        };\r\n        return points.filter(isUnique);\r\n    }\r\n    angle(vector) {\r\n        const product = this.dotProduct(vector);\r\n        const cosAngle = product / (this.magnitude() * vector.magnitude());\r\n        return Math.acos(cosAngle);\r\n    }\r\n}\r\n"}
