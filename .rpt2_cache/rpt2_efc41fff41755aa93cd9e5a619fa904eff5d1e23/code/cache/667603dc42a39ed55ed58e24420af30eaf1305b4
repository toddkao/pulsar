{"code":"import { uniqueId, contains } from '../util';\r\nexport default class Navigator {\r\n    constructor({ grid, begin, end, onExplore, onComplete, maxSteps, }) {\r\n        this.id = uniqueId();\r\n        this._path = [];\r\n        this.verticalCost = 1;\r\n        this.diagonalCost = 1.4;\r\n        this.tiles = [];\r\n        this.open = [];\r\n        this.closed = [];\r\n        this.registeredTiles = [];\r\n        this.steps = 0;\r\n        this.grid = grid;\r\n        this.begin = begin;\r\n        this.end = end;\r\n        this.onExplore = onExplore || (() => { });\r\n        this.onComplete = onComplete || (() => { });\r\n        this.maxSteps = maxSteps !== undefined ? maxSteps : Infinity;\r\n    }\r\n    get path() {\r\n        return this._path;\r\n    }\r\n    /** Begin the pathfinding process. Does not start if destination is an obstacle. */\r\n    start() {\r\n        if (this.end.isObstacle) {\r\n            return false;\r\n        }\r\n        this.closed.push(this.begin);\r\n        const beginNavData = this.begin.getNavigatorData(this);\r\n        this.addToExplored(this.begin);\r\n        beginNavData.gVal = 0;\r\n        this.calculateG(this.begin);\r\n        return true;\r\n    }\r\n    deregisterNavigatorData() {\r\n        this.registeredTiles.forEach((tile) => tile.deregisterNavigatorData(this));\r\n    }\r\n    calculateH(tile) {\r\n        const colVal = Math.abs(tile.position.x - this.end.position.x);\r\n        const rowVal = Math.abs(tile.position.y - this.end.position.y);\r\n        return colVal + rowVal;\r\n    }\r\n    calculateG(tile) {\r\n        const tileNavData = tile.getNavigatorData(this);\r\n        this.addToExplored(tile);\r\n        if (++this.steps === this.maxSteps) {\r\n            this.done([]);\r\n            return;\r\n        }\r\n        for (let i = 0; i < Navigator.neighborsCount; i++) {\r\n            const x = tile.position.x + Navigator.getColOffset(i);\r\n            const y = tile.position.y + Navigator.getRowOffset(i);\r\n            const exploring = this.grid.findTile({ x, y });\r\n            if (!exploring) {\r\n                continue;\r\n            }\r\n            const exploringNavData = exploring.getNavigatorData(this);\r\n            this.addToExplored(exploring);\r\n            if (exploring.isObstacle) {\r\n                continue;\r\n            }\r\n            if (contains(this.closed, exploring)) {\r\n                continue;\r\n            }\r\n            if (tile.id === exploring.id) {\r\n                this.closed.push(exploring);\r\n            }\r\n            else {\r\n                if (!this.getParent(tile, exploring, tileNavData, exploringNavData)) {\r\n                    continue;\r\n                }\r\n                if (!contains(this.open, exploring)) {\r\n                    this.open.push(exploring);\r\n                }\r\n                if (tile.isDiagonal(exploring)) {\r\n                    exploringNavData.gVal = tileNavData.gVal + this.diagonalCost;\r\n                }\r\n                else {\r\n                    exploringNavData.gVal = tileNavData.gVal + this.verticalCost;\r\n                }\r\n            }\r\n            exploringNavData.fVal = this.calculateF(exploring, exploringNavData);\r\n        }\r\n        const next = this.chooseNext();\r\n        if (next) {\r\n            this.onExplore(next);\r\n            this.calculateG(next);\r\n        }\r\n        else {\r\n            const path = this.getPath();\r\n            this.done(path);\r\n        }\r\n    }\r\n    done(path) {\r\n        this.deregisterNavigatorData();\r\n        this.onComplete(path);\r\n    }\r\n    calculateF(tile, data) {\r\n        const hVal = this.calculateH(tile);\r\n        return data.gVal + hVal;\r\n    }\r\n    static getRowOffset(iteration) {\r\n        /*\r\n           iteration = 0, 1, or 2: [-1][-1][-1]\r\n           iteration = 3, 4, or 5: [ 0][ 0][ 0]\r\n           iteration = 6, 7, or 8: [+1][+1][+1]\r\n         */\r\n        return Navigator.neighborsCount + -Math.floor((32 - iteration) / 3);\r\n    }\r\n    static getColOffset(iteration) {\r\n        /*\r\n           iteration = 0, 1, or 2: [-1][ 0][+1]\r\n           iteration = 3, 4, or 5: [-1][ 0][+1]\r\n           iteration = 6, 7, or 8: [-1][ 0][+1]\r\n         */\r\n        return (iteration % 3) - 1;\r\n    }\r\n    getParent(tile, checkTile, tileNavData, checkNavData) {\r\n        if (!checkNavData.parent) {\r\n            checkNavData.parent = tile;\r\n            return tile;\r\n        }\r\n        const moveCost = tile.isDiagonal(checkTile)\r\n            ? this.diagonalCost\r\n            : this.verticalCost;\r\n        if (tileNavData.gVal + moveCost < checkNavData.gVal) {\r\n            checkNavData.parent = tile;\r\n            return tile;\r\n        }\r\n        return null;\r\n    }\r\n    chooseNext() {\r\n        this.open.sort((a, b) => {\r\n            const aNavData = a.getNavigatorData(this);\r\n            const bNavData = b.getNavigatorData(this);\r\n            return aNavData.fVal - bNavData.fVal;\r\n        });\r\n        const next = this.open[0];\r\n        if (!next) {\r\n            return null;\r\n        }\r\n        this.open.shift();\r\n        this.closed.push(next);\r\n        if (next.id === this.end.id) {\r\n            return null;\r\n        }\r\n        return next;\r\n    }\r\n    getPath() {\r\n        this._path = [];\r\n        let current = this.end;\r\n        while (current.id !== this.begin.id) {\r\n            const currentNavData = current.getNavigatorData(this);\r\n            this._path.push(current);\r\n            if (currentNavData.parent) {\r\n                current = currentNavData.parent;\r\n            }\r\n            else {\r\n                return [];\r\n            }\r\n        }\r\n        this._path.reverse();\r\n        return this._path;\r\n    }\r\n    addToExplored(tile) {\r\n        if (!contains(this.registeredTiles, tile)) {\r\n            this.registeredTiles.push(tile);\r\n        }\r\n    }\r\n}\r\nNavigator.neighborsCount = 9;\r\n"}
